<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[网络是怎样连接的]]></title>
      <url>%2F2017%2F05%2F17%2F%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84%2F</url>
      <content type="text"><![CDATA[网络是怎样连接的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[5月计划]]></title>
      <url>%2F2017%2F05%2F02%2F5%E6%9C%88%E8%AE%A1%E5%88%92%2F</url>
      <content type="text"><![CDATA[五月计划： Binder]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Thinking in Java笔记之注解]]></title>
      <url>%2F2017%2F04%2F21%2FThinking-in-Java%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B3%A8%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[注解是Java SE5引进的新特性，它的产生也是来自像C#之类的语言对Java造成的语言特性压力所作出的一种回应。一个注解类看起来很像接口的定义，它与其他任何Java接口一样，注解也会将编译成class文件。 123456789package com.example.baichao.myapplication.annotation;import java.lang.annotation.*;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123;&#125; 除了@符号外，@TestAnnotation的定义更像一个空的接口。定义注解的时候，会需要一些元注解，如@Target和@Retention。@Target用来定义你的注解将应用于什么地方。@Retention用来定义该注解在哪一个级别可用，在源代码中(SOURCE)、类文件(CLASS)中或者运行时(RUNTIME)。没有元素的注解称为标记注解，例如上面的TestAnnotation。 元注解：@Target：表示该注解可以用于什么地方，可能的ElementType参数包括： CUNSTRUCTOR:构造器的声明 FIELD:域声明 LOCAL_VARIABLE:局部变量声明 METHOD:方法声明 PACKAGE:包申明 PARAMETER:参数声明 TYPE:类、接口（包括注解类型）或enum声明 @Retention：表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括： SOURCE:注解将被编译器丢弃 CLASS:注解在class文件中可用，但会被VM丢弃。 RUNTIME:VM将在运行期页保留注解，因此可以通过反射机制读取注解的信息。 @DOCUMENTED：此注解包含在Javadoc中。 @Inherited：允许自雷继承父类中的注解。 一个注解处理器 123456789101112131415161718192021222324public class UseCaseTracker &#123; public static void trackCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl) &#123; for (Method m : cl.getDeclaredMethods()) &#123; UseCase uc = m.getAnnotation(UseCase.class); if (uc != null) &#123; System.out.println("Found Use Case:" + uc.id() + " " + uc.description()); useCases.remove(new Integer(uc.id())); &#125; &#125; for (int i : useCases) &#123; System.out.println("Warning: Missing use case-" + i); &#125; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; useCases = new ArrayList&lt;Integer&gt;(); Collections.addAll(useCases,47,48,49,50); trackCases(useCases, PasswordUtils.class); &#125;&#125;//Found Use Case:47 nihao//Found Use Case:48 no description//Found Use Case:49 hello//Warning: Missing use case-50 编译器对元素的默认值要求比较严格，元素不能有不确定的值。元素必须要么有默认值，要么在使用注解时提供元素的值。对于非基本类型的元素，无论是在源代码中的声明时，或是在注解接口中定义默认值时，都不能以null作为其值。为了绕开这个约束，我们只能自己定义一些特殊的值，例如空字符串或负数，以此表示某个元素不存在。 123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface SimulatingNull &#123; public int id() default -1; public String description() default "";&#125; 假设你希望提供一些基本的对象/关系映射功能，能够自动生成数据库表，用以存储JavaBean对象。使用注解，你可以将所有信息都保存在JavaBean源文件中。 12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface DBTable &#123; public String name() default "";&#125; 接下来是为修饰IavaBean&amp;准备的注解： 12345678910111213141516171819202122@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Constraints &#123; boolean primaryKey() default false; boolean allowNull() default true; boolean unique() default false;&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface SQLString &#123; int value() default 0; String name() default ""; Constraints constraints() default @Constraints;&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface SQLInteger &#123; String name() default ""; Constraints constraints() default @Constraints;&#125; 注释可以嵌套，由于在@Constraints注解类型之后，没有在括号中指明@Constraints中元素的值，因此，constraints()元素的默认值实际上就是一个所有元素都为默认值的@Constraints注解。如果要令嵌入的@Constraints注解中的unique()元素为true，并以此作为constraints()元素的默认值，则需要如下定义该元素： 123public @interface Uniqueness &#123; Constraints constraints() default @Constraints(unique = true);&#125; 下面是一个简单的Bean定义 1234567891011121314151617181920212223@DBTable(name = "MEMBER")public class Member &#123; @SQLString(30) String firstName; @SQLString(50) String lastName; @SQLInteger Integer age; @SQLString(value = 30, constraints = @Constraints(primaryKey = true)) String handle; static int memberCount; public String getHandle() &#123; return handle; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public String toString() &#123; return handle; &#125; public Integer getAge() &#123; return age; &#125;&#125; 上面使用了快捷方式的注解（如果一个注解中定义了名为value的元素，并且在应用该注解的时候如果该元素是唯一需要赋值的一个元素，那么此时无须使用键值对的这种语法，而只需要在括号内给出value元素所需的值即可）这可以用于任何合法类型的元素，不过也限制了必须将此元素命名为value。如上例中：@SQLString(50)。 注解不支持继承不能使用关键字extends来继承某个@interface。 实现注解处理器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class TableCreator &#123; public static void main(String[] args) throws Exception&#123; if (args.length &lt; 1) &#123; System.out.println("arguments:annotated classes"); System.exit(0); &#125; for (String className : args) &#123; Class&lt;?&gt; cl = Class.forName(className); DBTable dbTable = cl.getAnnotation(DBTable.class); if (dbTable == null) &#123; System.out.println("No DBTable annotations in class " + className); continue; &#125; String tableName = dbTable.name(); if (tableName.length() &lt; 1) &#123; tableName = cl.getName().toUpperCase(); &#125; List&lt;String&gt; columnDefs = new ArrayList&lt;String&gt;(); for (Field field: cl.getDeclaredFields()) &#123; String columnName = null; Annotation[] anns = field.getDeclaredAnnotations(); if (anns.length &lt; 1) &#123; continue; &#125; if (anns[0] instanceof SQLInteger) &#123; SQLInteger sInt = (SQLInteger) anns[0]; if (sInt.name().length() &lt; 1) &#123; columnName = field.getName().toUpperCase(); &#125; else &#123; columnName = sInt.name(); &#125; columnDefs.add(columnName + " INT" + getConstraints(sInt.constraints())); &#125; if (anns[0] instanceof SQLString) &#123; SQLString sString = (SQLString) anns[0]; if (sString.name().length() &lt; 1) &#123; columnName = field.getName().toUpperCase(); &#125; else &#123; columnName = sString.name(); &#125; columnDefs.add(columnName + " VARCHAR(" + sString.value() + ")" + getConstraints(sString.constraints())); &#125; StringBuilder createCommand = new StringBuilder("CREATE TABLE " + tableName + "("); for (String columnDef : columnDefs) &#123; createCommand.append("\n " + columnDef + ","); &#125; String tableCreate = createCommand.substring(0 , createCommand.length() - 1) + ");"; System.out.println("Table Creation SQL for " + className + " is :\n" + tableCreate); &#125; &#125; &#125; private static String getConstraints(Constraints con) &#123; String constraints = ""; if (!con.allowNull()) &#123; constraints += " NOT NULL"; &#125; if (con.primaryKey()) &#123; constraints += " PRIMARY KRY"; &#125; if (con.unique()) &#123; constraints += " UNIQUE"; &#125; return constraints; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之结构型]]></title>
      <url>%2F2017%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之创建型]]></title>
      <url>%2F2017%2F04%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[建造者模式 123456789101112131415161718192021222324252627282930313233343536373839404142public class Person &#123; private final int mHeight; private final int mWeight; public Person (Builder builder) &#123; mHeight = builder.mHeight; mWeight = builder.mWeight; &#125; public int getHeight() &#123; return mHeight; &#125; public int getWeight() &#123; return mWeight; &#125; public static class Builder &#123; private int mHeight = 120; private int mWeight = 175; private Builder() &#123; &#125; public Builder setHeight(int height) &#123; mHeight = height; return this; &#125; public Builder setWeight(int weight) &#123; mWeight = weight; return this; &#125; public Person build() &#123; return new Person(this); &#125; &#125; &#125; 工厂方法 抽象工厂 单例模式 原型模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android事件分发]]></title>
      <url>%2F2017%2F04%2F17%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
      <content type="text"><![CDATA[TouchEvent事件分发机制全解析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Thinking in Java笔记之并发]]></title>
      <url>%2F2017%2F04%2F16%2FThinking-in-Java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B9%B6%E5%8F%91%2F</url>
      <content type="text"><![CDATA[Executor种类： Executors.newCachedThreadPool()：每次都会创建一个新线程 Executors.newFixedThreadPool(n)：创建一个大小为n的线程池 Executors.newSingleThreadExecutor()：相当于创建一个大小为1的线程池，所有任务都在一个线程里执行。 从任务中产生返回值： 使用Callable接口，使用ExecutorService.submit()方法进行调用，submit()方法会产生Future对象，它用Callable返回的结果的特定类型进行了参数化，并可以用isDone()方法来查询Future是否已经完成。当任务完成时，它具有一个结果，可以调用get()方法来获取该结果。 后台线程：是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的一部分。因此，当所有的费后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。 在线程启动之前调用setDaemon()方法设置为后台线程 123Thread daemon = new Thread();daemon.setDaemon(true);daemon.start(); 可以通过调用isDaemon()方法来确定线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程。 Join： 一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用t.join(),此线程将被挂起，直到目标线程t结束才恢复。对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法。 Synchronized关键字： 所有对象都自动含有单一的锁，当在对象上调用其任意synchronized方法的时候，此对象都被加锁，这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。对于某个特定对象来说，其所有的synchronized方法共享一个锁，这可以被用来防止多个任务同时访问被编码为对象内存。并且将域设置为private是非常重要的，否则synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。 一个对任务可以多次获得对象的锁，当首先获得了锁的任务才能允许继续获取多个锁，当锁计数为0的时候，锁被完全释放，此时别的任务就可以使用此资源。 使用显式的Lock对象 123456789private Lock lock = new ReentrantLock();public int next() &#123; lock.lock(); try &#123; &#125; finally &#123; lock.unlock(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有关Java闭包]]></title>
      <url>%2F2017%2F04%2F14%2F%E6%9C%89%E5%85%B3Java%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[关于对象与闭包的关系的一个有趣小故事 JVM的规范中允许编程语言语义中创建闭包(closure)吗？ - RednaxelaFX 的回答 为什么Java闭包不能通过返回值之外的方式向外传递值？ - RednaxelaFX 的回答 java为什么匿名内部类的参数引用时final?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Handler系列资源]]></title>
      <url>%2F2017%2F04%2F12%2FHandler%E7%B3%BB%E5%88%97%E8%B5%84%E6%BA%90%2F</url>
      <content type="text"><![CDATA[GityuanAndroid消息机制1-Handler(Java层) Android消息机制2-Handler(Native层) Android消息机制3-Handler(实战)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化]]></title>
      <url>%2F2017%2F04%2F11%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[Android性能优化几大考虑Mobile Context 资源受限 内存：普遍较小 CPU：核心少，计算能力有限 GPU：上传打的纹理，overdraw 内存开销大，会导致系统换入换出更频繁，GC频繁，APP被kill、被重启更频繁，不仅会消耗更多电量，而且GC会消耗大量时间，使得应用程序渲染速度低于60fps（GC耗时dalvik 10-20ms，ART 2-3ms） 外部存储与网络，也是受限的，需要考虑资源的使用、网络请求的优化 Memory Avoid Allocations in Inner Loops Avoid Allocations When Possible Cached objects Object pools：注意线程安全问题 ArrayList v.s. 数组 Android collections classes：HashMap v.s. ArrayMap/SimpleArrayMap Methods with mutated objects Avoid object types when primitive types will do：SparseIntArray，SparseLongArray Avoid arrays of objects Avoid Iterators：显式与隐式（foreach语句），会导致一个Iterator的分配，即便是空集合。 Avoid Enums Avoid Frameworks and Libraries Not Written for Mobile Applications Avoid Static Leaks Avoid Finalizers Avoid Excess Static Initialization Trim caches on demand Use isLowRamDevice：ActivityManager.isLowRamDevice() Avoid Requesting a Large Heap Avoid Running Services Longer than Necessary：BroadcastReceiver，IntentService Optimize for Code Size Use Proguard to strip out unused code Carefully consider your library dependencies Make sure to understand the cost of any code which is automatically generated Prefer simple, direct solutions to problems rather than creating a lot of infrastructure and abstractions to solve those problems Performance Avoid Expensive Operations During Animations and User Interaction 动画的每一帧渲染都是在UI线程的，如果有动画的时候进行耗时操作，很可能导致动画不流畅，耗时操作包括： Layout：当动画正在播放的时候，要避免改变View（延迟改变）；同时选择动画也需要避免会触发layout的动画，例如translationX，translationY只会导致延迟的layout操作，而LayoutParams属性，则会导致即时的layout。 Inflation：动画过程中避免inflate新的view，比如启动新的activity，或者ListView滑动到不同type的区域。 Launch Fast Avoid this problem by launching as fast as possible Also, avoid initialization code in your Application object Avoid Complex View Hierarchies One approach to avoiding complex nested hierarchies is to use custom views or custom layouts in some situations; it may be cheaper for a single view to draw several pieces of text and icons rather than have a series of nested ViewGroups to accomplish this. 结合的准则就是根据他们是否需要单独和用户完成交互（响应点击事件等） Avoid RelativeLayout Near the Top of the View Hierarchy RelativeLayout需要两次measurement passes才能确定布局正确，嵌套RelativeLayout，是幂乘关系 Avoid Expensive Operations on the UI Thread Minimize Wakeups Develop for the Low End Measure Performance Networking Don’t Over-Sync：batch it up with other system requests with JobScheduler or GCM Network Manager. Avoid Overloading the Server Don’t Make Assumptions about the Network Develop for Low End Networks Design Back-End APIs to Suit Client Usage Patterns：相关数据一个请求分发完毕；不相关的数据分接口分发；客户端应对获取的数据具备足够的信息； Language and Libraries Use Android-Appropriate Data Structures: ArrayMap, SparseArray Serialization Parcelable：安卓系统IPC格式；把Parcel写到磁盘是不安全的；解包方必须能访问Parcel的类，否则将失败；特定的类（Bitmap，CursorWindow）将被写到SharedPreference中，而通过Parcel传递的只是文件的fd，存在性能优化的空间，但是也节约了内存； Persistable Bundles：API 21引入，序列化为XML，支持的类型比Parcel少，但是为Bundle子类，某些场景方便处理； Avoid Java Serialization：额外开销更大，性能更差 XML and JSON：效率更低，复杂数据应考虑前述选项 Avoid JNI 需要考虑多种处理器架构，指针用long保存 java-&gt;jni, jni-&gt;java调用开销都很大，一次JNI调用做尽可能多的工作 内存管理，java对象管理jni对应对象的生命周期 错误处理，在调用JNI之前检查参数 参数对象尽量“传值”调用，即：展开后传递，不要在JNI里面使用指针访问成员，避免JNI过程中对象被回收 Prefer Primitive Types：内存、性能 Storage Avoid Hard-coded File Paths Persist Relative Paths Only Use Storage Cache for Temporary Files Avoid SQLite for Simple Requirements Avoid Using Too Many Databases Let User Choose Content Storage Location Framework Avoid Architecting Around Application Components Services Should Be Bound or Started, Not Both Prefer Broadcast over Service for Independent Events：Use broadcasts for delivering independent events; use services for processes with state and on-going lifecycle. Avoid Passing Large Objects Through Binder Isolate UI processes from Background Services User Interface Avoid Overdraw Avoid Null Window Backgrounds put the background drawable you want on the window itself with the windowBackground theme attribute and let those intervening containers keep their default transparent backgrounds. Avoid Disabling the Starting Window（windowDisablePreview/windowBackground） Allow Easy Exit from Immersive Mode Set Correct Status/Navigation Bar Colors in Starting Window Use the Appropriate Context Avoid View-Related References in Asynchronous Callbacks Design for RTL Cache Data Locally Cache User Input Locally Separate Network and Disk Background Operations Tools Host Tools Systrace Alerts and the Frames, 提示非常详尽，排查性能问题很方便 但是不知道怎么开启，monitor开启报错，命令行开启也报错，是手机系统的原因？ AllocationTracker AS集成，点击按钮，对APP进行操作，再点击按钮结束，capture将在AS中打开，查看哪里分配了内存，排查内存分配性能问题利器 Traceview 根据Traceview的结果，查看耗时排名靠前的方法，分析原因，提高性能 Hierarchyviewer 查看当前view hierarchy中每个view的绘制实践，绘制较慢的该工具会给出提示（不同颜色） MAT (Memory Analysis Tool) 先通过heap dump把堆快照导出，再通过MAT进行分析（实践？） Memory Monitor meminfo On-device tools StrictMode Profile GPU rendering Debug GPU overdraw Animator duration scale Screenrecord Show hardware layer updates Speed up your app Rules Always Measure Use[Experience] Slow Device Consider Trade-Offs Memory tips Bitmap’s pixel format Context Awareness HashMap v.s. ArrayMap/SparseArray LeakCanary Alpha TextView: setTextColor() instead of setAlpha() ImageView: setImageAlpha() instead of setAlpha() CustomView: handle alpha yourself by overriding onSetAlpha(), overriding hasOverlappingRendering() Hardware Acceleration view.setLayerType(View.LAYER_TYPE_HARDWARE, null) view.animate()….withLayer().start() 硬件加速非常适用于动画的渲染，但是也有需要注意的地方，ref 硬件加速的原理是GPU会把View绘制的结果缓存起来，后续的更新只需要重新渲染即可，省去了View的绘制，以及绘制指令的传输部分，但是硬件加速一开始的时候有额外的初始化工作（缓存） 如果View特别简单，仅仅是一个单颜色区域，那硬件加速的额外开销可能得不偿失 如果View在动画过程中不断invalidate，或者其内容不断变化，硬件加速的效果将大打折扣 如果动画发生在ViewGroup上，而其子View相对于ViewGroup也是在发生变化时，就不应该把硬件加速设置在ViewGroup上，因为动画过程中ViewGroup的内容是不断变化的（子View也在不断变化），而是应该把加速设置在各个子View上 GPU存储空间有限，仅当有必要时才使用硬件加速 profile GPU rendering和show hardware layers updates是很好的效果评估工具]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[invalidate与requestLayout]]></title>
      <url>%2F2017%2F04%2F10%2Finvalidate%E4%B8%8ErequestLayout%2F</url>
      <content type="text"><![CDATA[View的invalidate调用过程流程图 requestLayout流程图 requestLayout在ViewRootImpl里的入口： 1234567public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; 这里设置了mLayoutRequested为true，然后在scheduleTraversals里因为mLayoutRequested为true触发了performMeasure和performLayout，而performMeasure和performLayout里会调用onMeasure和onLayout。然后在performDraw内部draw的过程中发现mDirty为空，所以onDraw可能不会被调用。为什么是可能呢，因为在 layout里会调用setFrame，然后setFrame里如果发现宽高发生变化就会调用invalidate。 总结 view不停找parent可以一直找到DecorView，按理说DecorView是顶点了，但是DecorView还有个虚拟父view，ViewRootImpl。 ViewRootImpl不是一个View或者ViewGroup,他有个成员mView是DecorView，所有的操作从ViewRootImpl开始自上而下分发 view的invalidate不会导致ViewRootImpl的invalidate被调用，而是递归调用父view的invalidateChildInParent，直到ViewRootImpl的invalidateChildInParent，然后触发peformTraversals，会导致当前view被重绘,由于mLayoutRequested为false，不会导致onMeasure和onLayout被调用，而OnDraw会被调用 一个view的invalidate会导致本身PFLAG_INVALIDATED置1，导致本身以及父族viewgroup的PFLAG_DRAWING_CACHE_VALID置0 requestLayout会直接递归调用父窗口的requestLayout，直到ViewRootImpl,然后触发peformTraversals，由于mLayoutRequested为true，会导致onMeasure和onLayout被调用。不一定会触发OnDraw requestLayout触发onDraw可能是因为在在layout过程中发现l,t,r,b和以前不一样，那就会触发一次invalidate，所以触发了onDraw，也可能是因为别的原因导致mDirty非空（比如在跑动画） requestLayout会导致自己以及父族view的PFLAG_FORCE_LAYOUT和PFLAG_INVALIDATED标志被设置。 一般来说，只要刷新的时候就调用invalidate，需要重新measure就调用requestLayout。 附View绘制分析笔记之onMeasure View绘制分析笔记之onLayout View绘制分析笔记之onDraw]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Learn Python 3]]></title>
      <url>%2F2017%2F04%2F07%2FLearn-Python-3%2F</url>
      <content type="text"><![CDATA[Function1234567891011121314151617181920212223242526# this one is like your scripts with argvdef print_two(*args): arg1, arg2 = args print "arg1: %r, arg2: %r" % (arg1, arg2)# ok, that *args is actually pointless, we can just do thisdef print_two_again(arg1, arg2): print "arg1: %r, arg2: %r" % (arg1, arg2)# this just takes one argumentdef print_one(arg1): print "arg1: %r" % arg1# this one takes no argumentsdef print_none(): print "I got nothin'."print_two("Zed","Shaw")print_two_again("Zed","Shaw")print_one("First!")print_none()#arg1: 'Zed', arg2: 'Shaw'#arg1: 'Zed', arg2: 'Shaw'#arg1: 'First!'#I got nothin'.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[4月计划]]></title>
      <url>%2F2017%2F04%2F07%2F4%E6%9C%88%E8%AE%A1%E5%88%92%2F</url>
      <content type="text"><![CDATA[三月完成情况： [x] JVM原理学习 [x] Android的View绘制原理，动画原理 [ ] 进程间传输方式 [x] WindowManager相关知识 四月计划： Python学习 进程间传输方式 自定义组件深入]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Keep Burning]]></title>
      <url>%2F2017%2F04%2F05%2FKeep-Burning%2F</url>
      <content type="text"><![CDATA[恭喜IG在DAC以3比0的比分将冬虫夏草OG带走，燃烧哥夺冠！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Learn Python 2]]></title>
      <url>%2F2017%2F03%2F25%2FLearn-Python-2%2F</url>
      <content type="text"><![CDATA[Input标准输入12345678910111213print "How old are you?",age = raw_input()print "How tall are you?",height = raw_input()print "How much do you weigh?",weight = raw_input()print "So, you're %r old, %r tall and %r heavy." % (age, height, weight)#简化方式age1 = raw_input("How old are you? ")height1 = raw_input("How tall are you? ")weight1 = raw_input("How much do you weigh? ")print "So, you're %r old, %r tall and %r heavy." % (age1, height1, weight1) 多参输入12345678from sys import argvscript, first, second, third = argv#输入少于或者多余3个参数都会出错print "The script is called:", scriptprint "Your first variable is:", firstprint "Your second variable is:", secondprint "Your third variable is:", third 再来一个例子123456789101112131415161718192021from sys import argvscript, user_name = argvprompt = '&gt; 'print "Hi %s, I'm the %s script." % (user_name, script)print "I'd like to ask you a few questions."print "Do you like me %s?" % user_namelikes = raw_input(prompt)print "Where do you live %s?" % user_namelives = raw_input(prompt)print "What kind of computer do you have?"computer = raw_input(prompt)print """Alright, so you said %r about liking me.You live in %r. Not sure where that is.And you have a %r computer. Nice.""" % (likes, lives, computer) Reading Files123456789101112131415from sys import argvscript, filename = argvtxt = open(filename)print "Here's your file %r:" % filenameprint txt.read()print "Type the filename again:"file_again = raw_input("&gt; ")txt_again = open(file_again)print txt_again.read() open — Open a file. close — Closes the file.Like File-&gt;Save..in yout editor. read — Reads the contents if the file.You can assign the result to a variable. readline — Reads just one of a text file. truncate — Empties the file.Watch out if you care about the file. write(&#39;stuff&#39;) — Writes “stuff” to the file. More Files123456789101112131415161718192021222324from sys import argvfrom os.path import existsscript, from_file, to_file = argvprint "Copying from %s to %s" % (from_file, to_file)# we could do these two on one line, how?in_file = open(from_file)indata = in_file.read()print "The input file is %d bytes long" % len(indata)print "Does the output file exist? %r" % exists(to_file)print "Ready, hit RETURN to continue, CTRL-C to abort."raw_input()out_file = open(to_file, 'w')out_file.write(indata)print "Alright, all done."out_file.close()in_file.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android动画分析之Animation]]></title>
      <url>%2F2017%2F03%2F16%2FAndroid%E5%8A%A8%E7%94%BB%E5%88%86%E6%9E%90%E4%B9%8BAnimation%2F</url>
      <content type="text"><![CDATA[Android动画一直都在使用，今天分析一下其实现。 首先从View的startAnimation开始 123456public void startAnimation(Animation animation) &#123; animation.setStartTime(Animation.START_ON_FIRST_FRAME); setAnimation(animation); invalidateParentCaches(); invalidate(true);&#125; 通过setAnimation设置动画变量并刷新父视图绘画缓存 然后是invalidate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) &#123; if (mGhostView != null) &#123; mGhostView.invalidate(true); return; &#125; if (skipInvalidate()) &#123; return; &#125; if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123; if (fullInvalidate) &#123; mLastIsOpaque = isOpaque(); mPrivateFlags &amp;= ~PFLAG_DRAWN; &#125; mPrivateFlags |= PFLAG_DIRTY; if (invalidateCache) &#123; mPrivateFlags |= PFLAG_INVALIDATED; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID; &#125; // Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage); &#125; // Damage the entire projection receiver, if necessary. if (mBackground != null &amp;&amp; mBackground.isProjected()) &#123; final View receiver = getProjectionReceiver(); if (receiver != null) &#123; receiver.damageInParent(); &#125; &#125; // Damage the entire IsolatedZVolume receiving this view's shadow. if (isHardwareAccelerated() &amp;&amp; getZ() != 0) &#123; damageShadowReceiver(); &#125; &#125;&#125; invalidateChild 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public final void invalidateChild(View child, final Rect dirty) &#123; ViewParent parent = this; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; // If the child is drawing an animation, we want to copy this flag onto // ourselves and the parent to make sure the invalidate request goes // through final boolean drawAnimation = (child.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) == PFLAG_DRAW_ANIMATION; // Check whether the child that requests the invalidate is fully opaque // Views being animated or transformed are not considered opaque because we may // be invalidating their old position and need the parent to paint behind them. Matrix childMatrix = child.getMatrix(); final boolean isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp; child.getAnimation() == null &amp;&amp; childMatrix.isIdentity(); // Mark the child as dirty, using the appropriate flag // Make sure we do not set both flags at the same time int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY; if (child.mLayerType != LAYER_TYPE_NONE) &#123; mPrivateFlags |= PFLAG_INVALIDATED; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID; &#125; final int[] location = attachInfo.mInvalidateChildLocation; location[CHILD_LEFT_INDEX] = child.mLeft; location[CHILD_TOP_INDEX] = child.mTop; if (!childMatrix.isIdentity() || (mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123; RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); Matrix transformMatrix; if ((mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123; Transformation t = attachInfo.mTmpTransformation; boolean transformed = getChildStaticTransformation(child, t); if (transformed) &#123; transformMatrix = attachInfo.mTmpMatrix; transformMatrix.set(t.getMatrix()); if (!childMatrix.isIdentity()) &#123; transformMatrix.preConcat(childMatrix); &#125; &#125; else &#123; transformMatrix = childMatrix; &#125; &#125; else &#123; transformMatrix = childMatrix; &#125; transformMatrix.mapRect(boundingRect); dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f)); &#125; do &#123; View view = null; if (parent instanceof View) &#123; view = (View) parent; &#125; if (drawAnimation) &#123; if (view != null) &#123; view.mPrivateFlags |= PFLAG_DRAW_ANIMATION; &#125; else if (parent instanceof ViewRootImpl) &#123; ((ViewRootImpl) parent).mIsAnimating = true; &#125; &#125; // If the parent is dirty opaque or not dirty, mark it dirty with the opaque // flag coming from the child that initiated the invalidate if (view != null) &#123; if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp; view.getSolidColor() == 0) &#123; opaqueFlag = PFLAG_DIRTY; &#125; if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123; view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag; &#125; &#125; parent = parent.invalidateChildInParent(location, dirty); if (view != null) &#123; // Account for transform on current parent Matrix m = view.getMatrix(); if (!m.isIdentity()) &#123; RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); m.mapRect(boundingRect); dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f)); &#125; &#125; &#125; while (parent != null); &#125;&#125; ViewRootImpl的invalidateChildInParent方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; checkThread(); if (DEBUG_DRAW) Log.v(TAG, "Invalidate child: " + dirty); if (dirty == null) &#123; invalidate(); return null; &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123; return null; &#125; if (mCurScrollY != 0 || mTranslator != null) &#123; mTempRect.set(dirty); dirty = mTempRect; if (mCurScrollY != 0) &#123; dirty.offset(0, -mCurScrollY); &#125; if (mTranslator != null) &#123; mTranslator.translateRectInAppWindowToScreen(dirty); &#125; if (mAttachInfo.mScalingRequired) &#123; dirty.inset(-1, -1); &#125; &#125; final Rect localDirty = mDirty; if (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123; mAttachInfo.mSetIgnoreDirtyState = true; mAttachInfo.mIgnoreDirtyState = true; &#125; // Add the new dirty rect to the current one localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom); // Intersect with the bounds of the window to skip // updates that lie outside of the visible region final float appScale = mAttachInfo.mApplicationScale; final boolean intersected = localDirty.intersect(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); if (!intersected) &#123; localDirty.setEmpty(); &#125; if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123; scheduleTraversals(); &#125; return null;&#125; 这个方法主要作用是先确定哪些区域重新绘画，然后遍历绘画。接下来分析scheduleTraversals. 123456789101112void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); &#125;&#125; 接下来进入Choreographer 中的postCallback。对于Choreographe这个类非常的重要，它简单来说是一个消息处理器，包括用户输入，动画，绘图。 123public void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125; 1234567891011public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; if (action == null) &#123; throw new IllegalArgumentException("action must not be null"); &#125; if (callbackType &lt; 0 || callbackType &gt; CALLBACK_LAST) &#123; throw new IllegalArgumentException("callbackType is invalid"); &#125; postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125; 1234567891011121314151617181920212223private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; if (DEBUG) &#123; Log.d(TAG, "PostCallback: type=" + callbackType + ", action=" + action + ", token=" + token + ", delayMillis=" + delayMillis); &#125; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123; if (DEBUG) &#123; Log.d(TAG, "Scheduling next frame on vsync."); &#125; // If running on the Looper thread, then schedule the vsync immediately, // otherwise post a message to schedule the vsync from the UI thread // as soon as possible. if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); if (DEBUG) &#123; Log.d(TAG, "Scheduling next frame in " + (nextFrameTime - now) + " ms."); &#125; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; 这个 USE_VSYN是4.1之后才引入了，采用了三重缓存，大大提高了绘画效率。具体的可以查看官方资料对其描述。这个字段默认为true。一般情况下isRunningOnLooperThreadLocked()==true..接下来分析 123private void scheduleVsyncLocked() &#123; mDisplayEventReceiver.scheduleVsync();&#125; 这个方法是一个native方法会回调onVsync()方法。大概意思是把它自身的runnable加入到队列中。接下来执行调用run()。run调用doFrame方法。 1234567891011121314151617181920private final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_FRAME: doFrame(System.nanoTime(), 0); break; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync(); break; case MSG_DO_SCHEDULE_CALLBACK: doScheduleCallback(msg.arg1); break; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void doFrame(long frameTimeNanos, int frame) &#123; final long startNanos; synchronized (mLock) &#123; if (!mFrameScheduled) &#123; return; // no work to do &#125; startNanos = System.nanoTime(); final long jitterNanos = startNanos - frameTimeNanos; if (jitterNanos &gt;= mFrameIntervalNanos) &#123; final long skippedFrames = jitterNanos / mFrameIntervalNanos; if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123; Log.i(TAG, "Skipped " + skippedFrames + " frames! " + "The application may be doing too much work on its main thread."); &#125; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos; if (DEBUG) &#123; Log.d(TAG, "Missed vsync by " + (jitterNanos * 0.000001f) + " ms " + "which is more than the frame interval of " + (mFrameIntervalNanos * 0.000001f) + " ms! " + "Skipping " + skippedFrames + " frames and setting frame " + "time to " + (lastFrameOffset * 0.000001f) + " ms in the past."); &#125; frameTimeNanos = startNanos - lastFrameOffset; &#125; if (frameTimeNanos &lt; mLastFrameTimeNanos) &#123; if (DEBUG) &#123; Log.d(TAG, "Frame time appears to be going backwards. May be due to a " + "previously skipped frame. Waiting for next vsync."); &#125; scheduleVsyncLocked(); return; &#125; mFrameScheduled = false; mLastFrameTimeNanos = frameTimeNanos; &#125; doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); if (DEBUG) &#123; final long endNanos = System.nanoTime(); Log.d(TAG, "Frame " + frame + ": Finished, took " + (endNanos - startNanos) * 0.000001f + " ms, latency " + (startNanos - frameTimeNanos) * 0.000001f + " ms."); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线程安全与锁优化]]></title>
      <url>%2F2017%2F03%2F15%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[待完成。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java与线程]]></title>
      <url>%2F2017%2F03%2F15%2FJava%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[线程的实现实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。 使用内核线程实现内核线程就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核。 程序一般不糊直接去使用内核贤臣，而是去使用内核线程的一种高级接口——轻量级进程，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。 由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要再用户态和内核态中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。 使用用户线程实现狭义上用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的简历、同步、销毁、和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是坟场快速且低消耗的，也可以支持规模风大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。 它的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至不可能完成。 使用用户线程加轻量级进程混合实现Java线程的实现在JDK1.2之前，是基于称为“绿色线程”的用户线程实现的，而在JDK1.2中，线程模型替换为基于操作系统原生线程模型来实现。因此，在目前的JDK版本中，操作系统支持怎样的线程模型在很大程度上决定了Java虚拟机的线程需要使用哪种线程模型来实现。 Java线程调度线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。 协同式线程调度的线程执行时间由本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。优势是是实现简单，Lua语言中的“协同例程”就是这类实现。坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。 抢占式线程调度的每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。Java使用的线程调度方式就是抢占式调度。 虽然Java线程调度是系统自动完成的，但是我们可以建议系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点，这项操作可以通过设置线程优先级来完成。Java一共设置了10个级别的线程优先级。 123public static final int MAX_PRIORITY = 10;public static final int MIN_PRIORITY = 1;public static final int NORM_PRIORITY = 5; 不过，线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应，比如Windows中就只有7种，比Java线程优先级多的系统还好说，中间可以留下空位，但是比Java少的，就不得不出现几个优先级相同的情况了。 Java线程优先级 Windows线程优先级 1（Thread.MIN_PRIORITY） THREAD_PRIORITY_LOWEST 2 THREAD_PRIORITY_LOWEST 3 THREAD_PRIORITY_BELOW_NORMAL 4 THREAD_PRIORITY_BELOW_NORMAL 5（Thread.NORMAL_PRIORITY） THREAD_PRIORITY_NORMAL 6 THREAD_PRIORITY_ABOVE_NORMAL 7 THREAD_PRIORITY_ABOVE_NORMAL 8 THREAD_PRIORITY_HIGHEST 9 THREAD_PRIORITY_HIGHEST 10（Thread.MAX_PRIORITY） THREAD_PRIORITY_CRITICAL 优先级可能会被系统自行改变。在Windows系统中存在一个称谓优先级推进器的功能，当一个线程执行的特别努力的话，可能会越过线程优先级去为它分配执行时间。 状态转换Java语言定义了5种线程状态。 New Runnable Waiting Timed Waiting Blocked Terminated]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java内存模型]]></title>
      <url>%2F2017%2F03%2F14%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[主内存与工作内存Java内存模型的主要目标是定义程序中的各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量和Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。 Java内存模型规定了所有的变量都存储在主内存中（仅是虚拟机内存的一部分）。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下： 这里的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。 内存间交互操作Java内存模型中定义了以下8中操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。 lock：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 Volatile关键字当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，还有就是禁止指令重排序优化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM之类文件的结构]]></title>
      <url>%2F2017%2F03%2F13%2FJVM%E4%B9%8B%E7%B1%BB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[任何一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、集齐无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。虚拟机并不关心Class的来源是何种语言。 Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更为强大。因此，有一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础。 魔数与Class文件的版本 每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都是用魔数来进行身份识别。Class文件的魔数的获得很有意思，值为：0xCAFEBABE。（咖啡宝贝？） 紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Monor Version），第7和第8个字节是主版本号（Major Version）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM之内存分配与回收策略]]></title>
      <url>%2F2017%2F03%2F09%2FJVM%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%2F</url>
      <content type="text"><![CDATA[Java体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题： 给对象分配内存 以及回收分配给对象的内存 GC的区别 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。 老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。 对象优先在Eden分配 大多数情况下，对象在新生代Eden区中分配。当Eden去没有足够空间进行分配时，虚拟机将发起一次Minor GC。 大对象直接进入老年代 大对象是指需要大量连续内存空间的Java对象，最典型的大对象是很长的字符串以及数组。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置它们。 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄计算器。如果对象在Eden出生并经过一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加一岁，当它的年龄增加得到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升老奶奶年代的年龄阈值，可以通过参数配置 -XX:MaxTernuringThreshold设置。 动态对象年龄判定 为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringTreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxtenuringThreshold中要求的年龄。 空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 附：Android堆内存分代回收模型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM之垃圾收集器]]></title>
      <url>%2F2017%2F03%2F09%2FJVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
      <content type="text"><![CDATA[首先了解两个概念 并行(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发(Concurrent):指用户线程与垃圾收集器线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。 如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。不同厂商不同版本的虚拟机所提供的垃圾收集器都可能有很大的差别，这里谈论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机(在这个版本中正式提供了商用的G1收集器，之前的G1仍处于试验状态)，这个虚拟机包含的所有收集器如下图所示。 Serial收集器Serial是一个单线程的收集器，但它的“单线程”意义并不仅仅说明它只会使用一个CPU或一条手机此案成去完成垃圾和收集工作，更重要的是它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。 虽然很多缺点，但是它依然是虚拟机运行在Client模式下的默认新生代收集器，也有着它的优势：简单高效。 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，，其余行为包括Serial收集器可用的所有控制参数、手机算法、Stop The World、对象分配规则、回收策略都与Serila收集器完全一样。 它是运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作。 Parallel Scavenge收集器Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。它的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值（虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%）。也被称为“吞吐量优先”收集器。 Serial Old收集器Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义就是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中的Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Cocurrent Mode Failure时使用。 Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中，初始标记、重新标记这两个步骤仍然需要”Stop The world”。初始标记仅仅只是标记一下GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS的优势：并发收集、低停顿。 CMS的缺点： 对CPU资源非常敏感。CMS默认启动的回收线程数是(CPU数量 + 3)/4,并发回收时垃圾收集线程所占CPU资源随着CPU数量的增加而下降，而且在CPU不足4个时，CMS对用户程序的影响就可能变得很大，导致执行速度降低。 CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。 CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片太多的时候，将会给大对象分配带来很大麻烦。 G1收集器G1是一款面向服务端应用的垃圾收集器。HOtSpot开发团队赋予它的使命是未来可以替换掉CMS收集器。 G1具备如下特点： 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的就对象以获取更好的收集效果。 空间整合：G1从整体上来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，这意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。 可预测的停顿：这是G1相对于CMS的另一大优势。 在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，他们都是一部分Region（不需要连续）的集合。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解Java虚拟机之自动内存管理机制]]></title>
      <url>%2F2017%2F03%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些须臾都有各自的用途以及创建和销毁的时间。根据《Java虚拟机规范(Java SE 7版)》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域。 程序计数器程序计数器是一块较小的内存空间，他可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程计数器互不影响，独立存储。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。次内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同事都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口都信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译器克制的各种基本数据类型和对象引用。 本地方法栈本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。 Java堆此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么绝对了。 Java堆可以 处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池运行时常量池是方法区的一部分。Class文件中除了又累的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载进入方法区的运行时常量池中存放。 直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。NIO引入了一种基于通道与缓冲区的I/O方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Thinking in Java笔记 枚举]]></title>
      <url>%2F2017%2F03%2F01%2FThinking-in-Java%E7%AC%94%E8%AE%B0-%E6%9E%9A%E4%B8%BE%2F</url>
      <content type="text"><![CDATA[Thinking in Java笔记-枚举基本enum特性 调用enum的value()方法，可以遍历enum实例。values()方法返回enum实例的数组，而且该数组中的元素严格保持其在enum中声明时的顺序，所以可以在循环中使用values()返回的数组。 将静态导入用于enum(使用static import)。 enum可以使用在switch语句中。 123456789101112131415161718192021222324252627282930313233343536public enum Shrubbery &#123; GROUNG, CRAWING, HANGING&#125;public class EnumTest &#123; public static void main(String[] args) &#123; for (Shrubbery s : Shrubbery.values()) &#123; System.out.println(s + "ordinal:" + s.ordinal()); System.out.println(s.compareTo(Shrubbery.CRAWING)); System.out.println(s.equals(Shrubbery.CRAWING)); System.out.println(s == Shrubbery.CRAWING); System.out.println(s.getDeclaringClass()); System.out.println(s.name()); &#125; &#125;&#125;//GROUNGordinal:0//-1//false//false//class com.example.baichao.myapplication.myenum.Shrubbery//GROUNG//CRAWINGordinal:1//0//true//true//class com.example.baichao.myapplication.myenum.Shrubbery//CRAWING//HANGINGordinal:2//1//false//false//class com.example.baichao.myapplication.myenum.Shrubbery//HANGING 向enum中添加新的方法除了不能继承自一个enum之外，我们基本上可以将enum看做一个常规的类，也就是说，我们可以向enum中添加方法。enum甚至可以有main()方法。 123456789101112131415161718192021public enum OzWitch &#123; WEST("Hello,west"), EAST("Hello,east"), NORTH("Hello,north"), SOUTH("Hello,south"); private String description; private OzWitch(String description) &#123; this.description = description; &#125; public String getDescription() &#123; return description; &#125; public static void main(String[] args) &#123; for (OzWitch o: OzWitch.values()) &#123; System.out.println(o.getDescription()); &#125; &#125;&#125; 如果打算定义自己的方法，那么必须在enum实例序列的最后添加一个分号。 同时，必须先定义enum实例，如果在定义enum实例之前定义了任何方法或者属性，那么在编译时就会得到错误信息。 神秘的Values()方法编译器为你创建的enum类都是继承自Enum类。然而，如果你研究一下Enum类就会发现，它并没有values()方法。通过反编译可以知道答案，values()是由编译器添加的static方法。在创建自己的enum类的过程中，编译器还为其添加了valueOf()方法，而且这个valueOf()方法与本来的不一样，新增的只有一个参数，本来的需要两个参数。然后编译器还会将你的enum编辑为final类，所以无法被继承，还有一个static初始化子句。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[3月计划]]></title>
      <url>%2F2017%2F02%2F28%2F3%E6%9C%88%E8%AE%A1%E5%88%92%2F</url>
      <content type="text"><![CDATA[JVM原理学习 Android的View绘制原理，动画原理 进程间传输方式 WindowManager相关知识]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Learn Python(一)]]></title>
      <url>%2F2017%2F02%2F21%2FLearn-Python-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Learn Python(一) 打印 1print "Hello World" 注释 1#这是一条注释 更多变量与打印 123456789101112131415161718192021222324my_name = 'baichao'my_height = 176my_weight = 58print "Let's talk about %s" % my_nameprint "He's %d centimetres tall" % my_heightprint "He's %d kg heavy" % my_weightx = "There are %d types of people." % 10binary = "binary"do_not = "don't"y = "Those who know %s and those who %s." % (binary, do_not)print xprint yhilarious = Falsejoke_evaluation = "Isn't that joke so funny?! %r"print joke_evaluation % hilarious#使用\来进行转义print "I am 6'2\" tall."print 'I am 6\'2" tall.' 转义列表 Escape What it does \\ Backslash (\) \’ Single-quote (‘) \” Double-quote (“) \a ASCII bell (BEL) \b ASCII backspace (BS) \f ASCII formfeed (FF) \n ASCII linefeed (LF) \N{name} Character named name in the Unicode database (Unicode only) \r Carriage Return (CR) \t Horizontal Tab (TAB) \uxxxx Character with 16-bit hex value xxxx (u’’ string only) \Uxxxxxxxx Character with 32-bit hex value xxxxxxxx (u’’ string only) \v ASCII vertical tab (VT) \ooo Character with octal value ooo \xhh Character with hex value hh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Thinking in Java 笔记(三)]]></title>
      <url>%2F2017%2F02%2F16%2FThinking-in-Java-%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
      <content type="text"><![CDATA[Thinking in Java 笔记(三)Chapter 15 泛型通配符被限制为单一边界 1234//你可以这么做List&lt;? extends SuperHearing&gt; audioBoys;//但是你不能这么做List&lt;? extends SuperHearing &amp; SuperSmell&gt; dogBoys; 通配符 123Holder&lt;Apple&gt; Apple = new Holder&lt;Apple&gt;(new Apple());Holder&lt;Fruit&gt; fruit = Apple; //不行，不能向上转型Holder&lt;? extends Fruit&gt; fruit = Apple; //可以，但是不能调用任何参数为泛型的方法，比如set() 超类型通配符]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Thinking in Java 笔记(二)]]></title>
      <url>%2F2017%2F02%2F15%2FThinking-in-Java-%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[Thinking in Java 笔记（二）Chapter14 类型信息当使用“.class”来创建对Class对象的引用时，不会自动的初始化该Class对象。为了使用类而做的准备工作实际包含三个步骤： 加载。这是由类加载器执行的。该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个Class对象。 链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果是必须的话，将解析这个类创建的对其他类的所有引用。 初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化快。 初始化有效的实现了尽可能的“惰性”。仅使用.class语法获得对类的引用不会引发初始化。但是，为了产生Class引用，Class .forName()立即就进行了初始化。如果一个static final值是编译器常量，那么这个值不需要对类进行初始化就可以读取。但是，如果只是将一个域设置为static和final的，还不足以确保这种行为（如果不是编译期常量）。如果一个static域不是final的，那么在对它访问时，总是要求在它被读取前先进行链接和初始化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java集合框架]]></title>
      <url>%2F2017%2F02%2F14%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio 快捷键]]></title>
      <url>%2F2017%2F02%2F14%2FAndroid-Studio-%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[Android Studio 快捷键（Mac） 查看类的结构：Cmd + 7 查看类的文档结构：Cmd + f12 查看类的继承关系：Control + H 查看接口方法实现：Cmd + alt + B]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Thinking in Java 笔记]]></title>
      <url>%2F2017%2F02%2F09%2FThinking-in-Java-%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Thinking in Java 笔记Chapter8 多态对象调用顺序： 调用基类的构造器 按声明顺序调用成员的初始化方法 调用导出类构造器的主体 对象销毁顺序：对于继承的层次结构中，如果一个类需要被销毁，应该先对其导出类进行清理，然后才是基类。 构造器编写准则用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法。构造器内唯一能够安全调用的那些方法是基类中的final方法（也适用于private方法，他们自动属于final方法）。 继承准则 用继承表达行为间的差异，并用字段表达状态上的变化。 Chapter9 接口接口嵌套以及作用域123456789101112131415161718192021222324252627282930public class A &#123; private B bRef; private interface B &#123; void f(); &#125; private class BImp implements B &#123; @Override public void f() &#123; &#125; &#125; public class BImp2 implements B &#123; @Override public void f() &#123; &#125; &#125; public B getB() &#123; return new BImp2(); &#125; public void receiveB(B b) &#123; bRef = b; bRef.f(); &#125;&#125; 1234567891011121314151617181920public class NestingInterfaces &#123; public static void main(String[] args) &#123; A a = new A(); //B是private,无法访问 //! A.B ab = a.getB(); //需要A.BImp2,但是返回的是A.B //! A.BImp2 bImp2 = a.getB(); //不能访问接口的成员 //! a.getB().f(); //只有另一个A可以对getB()做操作 A a2 = new A(); a2.receiveB(a.getB()); &#125;&#125; Chapter10 内部类访问权限内部类可以访问外围类的所有成员，而不需要任何条件，并且还拥有外围类的所有元素的访问权。 创建内部类对象创建内部类对象不能直接引用外部类的名字，而必须使用外部类的对象来创建内部类对象，如下需要使用.new关键字进行创建。 123456789101112public class DotNew &#123; public class Inner &#123; &#125; public static void main(String[] args) &#123; DotNew dn = new DotNew(); DotNew.Inner dni = dn.new Inner(); &#125;&#125; 内部类的覆盖1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Egg2 &#123; protected class Yolk &#123; public Yolk() &#123; System.out.println("Egg2.Yolk()"); &#125; public void f() &#123; System.out.println("Egg2.Yolk().f()"); &#125; &#125; private Yolk y = new Yolk(); public Egg2() &#123; System.out.println("New Egg2"); &#125; public void insertYolk(Yolk yy) &#123; y = yy; &#125; public void g() &#123; y.f(); &#125;&#125;public class BigEgg2 extends Egg2&#123; public class Yolk extends Egg2.Yolk &#123; public Yolk() &#123; System.out.println("BigEgg2.Yolk()"); &#125; public void f() &#123; System.out.println("BigEgg2.Yolk().f()"); &#125; &#125; public BigEgg2() &#123; insertYolk(new Yolk()); &#125; public static void main(String[] args) &#123; Egg2 e2 = new BigEgg2(); e2.g(); &#125;&#125;//Egg2.Yolk()//New Egg2//Egg2.Yolk()//BigEgg2.Yolk()//BigEgg2.Yolk().f() 使用局部内部类而非匿名内部类的理由：需要一个已命名的构造器，或者组要重载构造器，而匿名内部类只能用于实例初始化，或需要不止一个该内部类的对象。 Chapter11 持有对象 foreach可以用于数组和任何Iterable]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017,brand new life]]></title>
      <url>%2F2017%2F02%2F07%2F2017-brand-new-life%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F07%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava流水浅析]]></title>
      <url>%2F2016%2F11%2F11%2FRxJava%E6%B5%81%E6%B0%B4%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[RxJava一个典型的流程如下： 123456789101112131415161718192021222324252627Subscription s = Observable.create(new Observable.OnSubscribe&lt;UpdateInfo&gt;() &#123; @Override public void call(Subscriber&lt;? super UpdateInfo&gt; subscriber) &#123; if (!subscriber.isUnsubscribed()) &#123; subscriber.onNext(getAndSaveUpdateInfo(data)); //获取升级信息 subscriber.onCompleted(); &#125; &#125; &#125;).observeOn( Schedulers.io() ).filter(new Func1&lt;UpdateInfo, Boolean&gt;() &#123; @Override public Boolean call(UpdateInfo imUpdateVO) &#123; return filterDownloadInfo(imUpdateVO); //过滤升级信息，错误以及下载过，不再下载，需在异步线程，有远程文件大小校验 &#125; &#125;).observeOn( AndroidSchedulers.mainThread() ).subscribe(new SimpleSubscriber&lt;UpdateInfo&gt;() &#123; @Override public void onNext(UpdateInfo imUpdateVO) &#123; super.onNext(imUpdateVO); if (downloadHelper != null) &#123; downloadHelper.downApkByImUpdateVO(imUpdateVO); &#125; &#125; &#125;); addSubscription(s); 上面是一个app的检测升级的逻辑代码，流式的逻辑浅显易懂，能够让你清晰的理清代码逻辑，这就是函数式变成的一大优点。所以在这里，我主要想聊一下RxJava流式运行的原理，我想从以下几点来讲述： Create Subscribe Operator subscribeOn与observeOn 被压与冷热发射 Subject与RxBus Demo1Observable.create(onSubscribe) .subscribe(subscriber); Demo2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git学习]]></title>
      <url>%2F2015%2F07%2F28%2Fgit%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[基本操作 创建一个空目录 mkdir learngit 创建目录 cd learngit 进入目录 pwd 显示目录 将这个目录变成Git可以管理的仓库 git init 仓库初始化 编写一个文件比如file.txt放入learngit文件夹，并使用以下命令将文件添加至仓库，add放入暂存区，commit提交 git add file.txt 用命令git commit告诉Git，把文件提交到仓库,-m后为提交说明 git commit -m &quot;add file.txt&quot; 修改file.txt后用git status来查看仓库状态 git status 使用git diff来查看文件的修改状态 git diff file.txt git log查看改动日志，后面加--pretty=oneline可以使输入变成一行 回退上一个版本git reset --hard HEAD^,上上个版本是HEAD^^,第n个版本是HEAD~100，你让HEAD指向哪个版本号，你就把当前版本定位在哪。 用git log可以查看提交历史，以便确定要回退到哪个版本，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 删除文件 git rm 文件名 把本地仓库的内容推送到GitHub仓库 git remote add origin https:/github.com/自己的github账号/仓库名git push -u origin master 第一次提交需要加上-u，之后每次提交就不用了 关联一个远程库，使用命令 git remote add origin git@server-name:path/repo-name.git 创建和合并分支 创建dev分支并切换至dev分支 git checkout -b dev 加上-b参数表示创建并切换，相当于以下两条命令： git branch dev git checkout dev 合并某分支到当前分支 git merge &lt;name&gt; 删除dev分支 git branch -d dev 推送分支dev至远程仓库origin git push origin dev 多人协作 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二叉树相关]]></title>
      <url>%2F2015%2F04%2F25%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208package com.example.baichao.myapplication.algorithm;import java.util.LinkedList;import java.util.Queue;import java.util.Stack;public class BinaryTreeNode&lt;T&gt; &#123; private String name; private T data; private boolean isLeaf; private BinaryTreeNode&lt;T&gt; left; private BinaryTreeNode&lt;T&gt; right; public BinaryTreeNode(String name, T data) &#123; this.name = name; this.data = data; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public BinaryTreeNode&lt;T&gt; CreateAndJionLeft(String name, T data) &#123; return left = new BinaryTreeNode&lt;T&gt;(name, data); &#125; public BinaryTreeNode&lt;T&gt; CreateAndJionRight(String name, T data) &#123; return right = new BinaryTreeNode&lt;T&gt;(name, data); &#125; public boolean isLeaf() &#123; isLeaf = (left == null &amp;&amp; right == null); return isLeaf; &#125; /** * 前序遍历 */ public void PreOrderTraversal() &#123; if (this != null) &#123; System.out.println(name); &#125; if (left != null) &#123; left.PreOrderTraversal(); &#125; if (right != null) &#123; right.PreOrderTraversal(); &#125; &#125; /** * 前序遍历非递归 */ public void PreOrderTraversalEx() &#123; Stack&lt;BinaryTreeNode&lt;T&gt;&gt; stack = new Stack&lt;BinaryTreeNode&lt;T&gt;&gt;(); BinaryTreeNode&lt;T&gt; node = this; while (node != null || stack.size() != 0) &#123; while (node != null) &#123; System.out.println(node.name); stack.push(node); node = node.left; &#125; if (stack.size() != 0) &#123; node = stack.pop(); node = node.right; &#125; &#125; &#125; /** * 中序遍历 */ public void InOrderTraversal() &#123; if (left != null) &#123; left.InOrderTraversal(); &#125; if (this != null) &#123; System.out.println(name); &#125; if (right != null) &#123; right.InOrderTraversal(); &#125; &#125; /** * 中序遍历非递归 */ public void InOrderTraversalEx() &#123; Stack&lt;BinaryTreeNode&lt;T&gt;&gt; stack = new Stack&lt;BinaryTreeNode&lt;T&gt;&gt;(); BinaryTreeNode&lt;T&gt; node = this; while (node != null || stack.size() != 0) &#123; while (node != null) &#123; stack.push(node); node = node.left; &#125; if (stack.size() != 0) &#123; node = stack.peek(); stack.pop(); System.out.println(node.name); node = node.right; &#125; &#125; &#125; /** * 后序遍历 */ public void PostOrderTraversal() &#123; if (left != null) &#123; left.PostOrderTraversal(); &#125; if (right != null) &#123; right.PostOrderTraversal(); &#125; if (this != null) &#123; System.out.println(name); &#125; &#125; /** * 后序遍历非递归 */ public void PostOrderTraversalEx() &#123; Stack&lt;BinaryTreeNode&lt;T&gt;&gt; stack = new Stack&lt;BinaryTreeNode&lt;T&gt;&gt;(); BinaryTreeNode&lt;T&gt; node = this; BinaryTreeNode&lt;T&gt; lastNode = null; stack.push(node); while (stack.size()!=0) &#123; node = stack.peek(); if ((node.left == null &amp;&amp; node.right == null) || (lastNode != null &amp;&amp; (lastNode == node.left || lastNode == node.right))) &#123; //如果当前结点没有子结点或者子节点都已被访问过就输出 因为后序遍历是先子节点再根节点 System.out.println(node.name); stack.pop(); lastNode = node;//设定本次访问的节点为上一次访问的节点 &#125; else &#123; if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); &#125; &#125; &#125; /** * 反转二叉树(递归) */ public BinaryTreeNode&lt;T&gt; ReverseWithRecursive() &#123; if (this == null) &#123; return null; &#125; if (!(left == null &amp;&amp; right == null)) &#123; BinaryTreeNode&lt;T&gt; temp = right;//左右节点反转 right = left; left = temp; if (left != null) left = left.ReverseWithRecursive();//递归反转左子节点 if (right != null) right = right.ReverseWithRecursive();//递归反转右子节点 &#125; return this; &#125; /** * 反转二叉树(非递归) */ public BinaryTreeNode&lt;T&gt; Reverse() &#123; if (this == null) &#123; return null; &#125; Queue&lt;BinaryTreeNode&lt;T&gt;&gt; nodeQueue = new LinkedList&lt;BinaryTreeNode&lt;T&gt;&gt;(); nodeQueue.add(this); while (nodeQueue.size() &gt; 0) &#123; BinaryTreeNode&lt;T&gt; node = nodeQueue.peek(); nodeQueue.remove(); BinaryTreeNode&lt;T&gt; tempNode = node.right;//左右节点反转 node.right = node.left; node.left = tempNode; if (node.left != null) &#123; nodeQueue.add(node.left); &#125; if (node.right != null) &#123; nodeQueue.add(node.right); &#125; &#125; return this; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组排序]]></title>
      <url>%2F2015%2F04%2F20%2F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167public class SortAlgorithm &#123; /** * 快速排序 * @param data */ public static void quick(int[] data) &#123; if (data.length &gt; 0) &#123; quickSort(data, 0, data.length - 1); &#125; &#125; /** * @param numbers 带排序数组 * @param low 开始位置 * @param high 结束位置 */ public static void quickSort(int[] numbers, int low, int high) &#123; if (low &lt; high) &#123; int middle = getMiddle(numbers, low, high); //将numbers数组进行一分为二 quickSort(numbers, low, middle - 1); //对低字段表进行递归排序 quickSort(numbers, middle + 1, high); //对高字段表进行递归排序 &#125; &#125; /** * 查找出中轴（默认是最低位low）的在numbers数组排序后所在位置 * @param numbers 带查找数组 * @param low 开始位置 * @param high 结束位置 * @return 中轴所在位置 */ public static int getMiddle(int[] numbers, int low, int high) &#123; int temp = numbers[low]; //数组的第一个作为中轴 while (low &lt; high) &#123; while (low &lt; high &amp;&amp; numbers[high] &gt; temp) &#123; high--; &#125; numbers[low] = numbers[high];//比中轴小的记录移到低端 while (low &lt; high &amp;&amp; numbers[low] &lt; temp) &#123; low++; &#125; numbers[high] = numbers[low]; //比中轴大的记录移到高端 &#125; numbers[low] = temp; //中轴记录到尾 return low; // 返回中轴的位置 &#125; /** * 归并排序 * 简介:将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列 * 时间复杂度为O(nlogn) * 稳定排序方式 * @param nums 待排序数组 * @return 输出有序数组 */ public static int[] MergeSort(int[] nums, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; // 左边 MergeSort(nums, low, mid); // 右边 MergeSort(nums, mid + 1, high); // 左右归并 merge(nums, low, mid, high); &#125; return nums; &#125; /** * 将数组中low到high位置的数进行排序 * @param nums 待排序数组 * @param low 待排的开始位置 * @param mid 待排中间位置 * @param high 待排结束位置 */ public static void merge(int[] nums, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low;// 左指针 int j = mid + 1;// 右指针 int k = 0; // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (nums[i] &lt; nums[j]) &#123; temp[k++] = nums[i++]; &#125; else &#123; temp[k++] = nums[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; temp[k++] = nums[i++]; &#125; // 把右边边剩余的数移入数组 while (j &lt;= high) &#123; temp[k++] = nums[j++]; &#125; // 把新数组中的数覆盖nums数组 for (int k2 = 0; k2 &lt; temp.length; k2++) &#123; nums[k2 + low] = temp[k2]; &#125; &#125; /** * 堆排序 * @param data */ public static void HeapSort(int[] data) &#123; int arrayLength = data.length; //循环建堆 for (int i = 0; i &lt; arrayLength - 1; i++) &#123; //建堆 buildMaxHeap(data, arrayLength - 1 - i); //交换堆顶和最后一个元素 swap(data, 0, arrayLength - 1 - i); System.out.println(Arrays.toString(data)); &#125; &#125; /** * 对data数组从0到lastIndex建大顶堆 * @param data * @param lastIndex */ public static void buildMaxHeap(int[] data, int lastIndex) &#123; //从lastIndex处节点（最后一个节点）的父节点开始 for (int i = (lastIndex - 1) / 2; i &gt;= 0; i--) &#123; //k保存正在判断的节点 int k = i; //如果当前k节点的子节点存在 while (k * 2 + 1 &lt;= lastIndex) &#123; //k节点的左子节点的索引 int biggerIndex = 2 * k + 1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if (biggerIndex &lt; lastIndex) &#123; //若果右子节点的值较大 if (data[biggerIndex] &lt; data[biggerIndex + 1]) &#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if (data[k] &lt; data[biggerIndex]) &#123; //交换他们 swap(data, k, biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k = biggerIndex; &#125; else &#123; break; &#125; &#125; &#125; &#125; private static void swap(int[] data, int i, int j) &#123; int tmp = data[i]; data[i] = data[j]; data[j] = tmp; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[链表]]></title>
      <url>%2F2015%2F03%2F13%2F%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[翻转一个链表 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode prefix = dummy; int count = n - m + 1; m--; while (m &gt; 0) &#123; prefix = prefix.next; m--; &#125; ListNode pre = null; ListNode p = prefix.next; ListNode reversedTail = p; while (count &gt; 0) &#123; ListNode temp = p.next; p.next = pre; pre = p; p = temp; count--; &#125; prefix.next = pre; if (reversedTail != null) &#123; reversedTail.next = p; &#125; return dummy.next; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[集合子集问题]]></title>
      <url>%2F2015%2F03%2F10%2F%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[不包含重复的If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; 包含重复的If nums = [1,2,2], a solution is: 12345678[ [2], [1], [1,2,2], [2,2], [1,2], []] 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125;]]></content>
    </entry>

    
  
  
</search>
